#include <WiFi.h>        // conectar a WiFi
#include <HTTPClient.h>  // enviar datos a la API (como mandar un mensaje).
#include <MFRC522.h>     // Biblioteca para leer tarjetas RFID (como un lector de códigos).
#include <ArduinoJson.h>

// Pines para el módulo RFID
#define SS_PIN 5   // Pin de selección de esclavo (Slave Select) para SPI.
#define RST_PIN 18 // Pin de reset para el módulo RFID.
MFRC522 rfid(SS_PIN, RST_PIN);  // Crea objeto rfid con pines definidos. Controla la comunicación con el lector RFID.

// Configuración WiFi y API
const char* ssid = "PEINE-3";
const char* password = "etecPeine3";
const char* serverUrl = "http://10.56.13.13:5000/registro";  // Cambia a tu URL de la API en Python.

void setup() {
  Serial.begin(115200);  // Inicia comunicación con la computadora (para ver mensajes).
  SPI.begin();           // Inicia SPI (como un bus para conectar dispositivos).
  rfid.PCD_Init();       // Enciende el lector RFID (lo prepara para leer tarjetas).
//Recomendacion, usar un while si no hay wifi
  Serial.println("conectando a wifi");
  WiFi.begin(ssid, password);              // Conecta a WiFi.
  while (WiFi.status() != WL_CONNECTED) {  // Espera hasta conectar.
  Serial.print(".");
    delay(1000);                           // Espera 1 segundo.
  }
  Serial.println("Conectado a WiFi!");  // Mensaje de éxito.
  Serial.println("setupok!");  // Mensaje de éxito.
}

void loop() {
  // Revisa si hay una tarjeta cerca.
  if (!rfid.PICC_IsNewCardPresent() || !rfid.PICC_ReadCardSerial()) {
    return;  // Si no hay tarjeta, vuelve al inicio.
  }
  // Lee el código único de la tarjeta (UID).
  String uid = "";                            // Variable para guardar el UID.
  for (byte i = 0; i < rfid.uid.size; i++) {  // Recorre cada parte del UID.
    uid += String(rfid.uid.uidByte[i], HEX);  // Convierte a letras/números y agrega.
  }
  Serial.println("Tarjeta leída: " + uid);  //LEER LA TARJETA
  //PARA AGINAR ESA INFO A UN ID_EMPLEADO

  if (WiFi.status() == WL_CONNECTED) {  // Si WiFi está conectado.
    HTTPClient http;  // Crea objeto para enviar datos.
    http.begin(serverUrl);  // Apunta a la API.
    http.addHeader("Content-Type", "application/json");  // Dice que envía JSON.
    
    //NO desserializamos, SERIALIZAMOS
    JsonDocument doc;
    //armamos el diccionario
    doc["id_llave"] = uid;
    doc["tipo"] = "entrada"; //Asignamos que este sensor sea para entrada
    // Crea mensaje JSON con ID y tipo (entrada).
    String jsonData;
    serializeJson(doc, jsonData);
    int respuesta = http.POST(jsonData);  // Envía el mensaje.
    
    if (respuesta > 0) {  // Si envió bien.
        Serial.println("Enviado a API: " + http.getString());  // Muestra respuesta.
    } else {  // Si falló.
        Serial.println("Error al enviar");
    }
    
    // Lee el UID (identificador único) de la tarjeta RFID.
    // El UID es un array de bytes que identifica la tarjeta.
    String uid = "";
    for (byte i = 0; i < rfid.uid.size; i++) {
        uid += String(rfid.uid.uidByte[i], HEX);  // Convierte cada byte a hexadecimal y lo concatena.
    }
    Serial.println("UID leído: " + uid);  // Imprime el UID para depuración.
    
    // Mapea el UID a un id_empleado (en producción, usa una lista o API para esto).
    int id_empleado = 1;
    
    // Envía datos a la API vía HTTP POST.
    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin(serverUrl);
        http.addHeader("Content-Type", "application/json");
        
        // Crea JSON con datos: id_empleado y tipo (entrada/salida).
        String jsonData = "{\"id_empleado\":" + String(id_empleado) + ", \"tipo\":\"entrada\"}";
        int httpResponseCode = http.POST(jsonData);  // Envía POST a la API.
        
        if (httpResponseCode > 0) {
            Serial.println("Respuesta API: " + http.getString());  // Imprime respuesta de la API.
        } else {
            Serial.println("Error en envío a API");
        }
        http.end();
    }
    
    rfid.PICC_HaltA();  // Detiene la comunicación con la tarjeta actual para evitar lecturas repetidas.
    delay(2000);  // Pausa para evitar lecturas múltiples rápidas.
  }
}